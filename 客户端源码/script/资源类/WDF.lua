--======================================================================--
-- @作者: GGE研究群: 342119466
-- @创建时间:   2018-03-03 02:34:19
-- @Last Modified time: 2023-10-18 13:11:25
-- 梦幻西游游戏资源破解 baidwwy@vip.qq.com(313738139) 老毕   和 C++PrimerPlus 717535046 这俩位大神破解所以资源
--======================================================================--
local ffi  = require("ffi")
local new  = ffi.new
local wdf  = class()
local _Ptr = nil--全局共享内存 5242880 10485760 20971520
local _Max = 0
local niceKey = {
        0x82,0xAC,0x6A,0x44,0x54,0x50,0x12,0xCC,0x62,0xB2,0x4B,0xAE,0xF4,0xDF,0x9C,0xAF,
        0xB3,0xB1,0xBD,0x84,0x17,0xB3,0x0D,0x43,0x15,0x53,0x24,0x95,0xE6,0x8D,0x52,0x95,
        0x58,0x73,0x0A,0x20,0xA9,0x3E,0x54,0x6E,0x29,0xC6,0x2F,0x71,0x73,0x8F,0x41,0x99,
        0x43,0xB4,0xBC,0x2B,0x80,0x64,0xBE,0xCD,0x9F,0x28,0x30,0x01,0x2C,0x7C,0xE5,0xD3,
        0x60,0xB5,0x57,0x81,0xD6,0x7C,0x06,0x76,0x5D,0x50,0x5B,0x50,0x84,0x9A,0xCE,0x84,
        0x12,0x8A,0x52,0x32,0xD0,0x27,0x15,0xF2,0xB4,0x3B,0x80,0x82,0x0F,0x54,0x42,0xAC,
        0xE0,0x5B,0x12,0xBD,0x39,0xBF,0xC1,0xC6,0xAE,0x47,0xCC,0x31,0x0A,0x6F,0x4A,0x06,
        0x58,0xAA,0xED,0xA0,0x2B,0xB3,0x03,0x39,0xA1,0x64,0xCC,0x9C,0xFB,0x83,0x67,0x0A,
        0x0E,0xAE,0x6E,0x2A,0x88,0x11,0x4C,0x52,0xC8,0x8B,0x83,0x89,0x5A,0xE3,0xE9,0x45,
        0xF0,0x7A,0x2A,0x63,0x65,0xA1,0x82,0x2E,0x58,0xD8,0x1D,0xD4,0xF2,0x26,0xC9,0x2B,
        0xDE,0xC3,0x23,0x5B,0x02,0x20,0x7C,0x47,0x5F,0x9C,0xD7,0x9F,0x30,0x79,0xDE,0xBC,
        0x79,0x87,0xAA,0x81,0x59,0x05,0xA4,0x6C,0x2C,0x40,0xD1,0xAF,0xF3,0x76,0x5F,0xA3,
        0xC0,0x58,0xAA,0x95,0xC0,0x8F,0x44,0xD0,0xFD,0xE1,0x04,0xC8,0xC8,0xE2,0xFD,0xDE,
        0xF8,0x5F,0x5B,0x6B,0x7A,0x49,0xD1,0xD9,0x1F,0xB6,0x2F,0xC0,0x4E,0xCB,0x53,0xE7,
        0x3D,0x35,0xDD,0xD6,0xCD,0x49,0xFB,0xE9,0x44,0xD9,0x82,0x77,0x01,0xDA,0xA2,0x49,
        0x42,0xF1,0xB6,0x95,0x1C,0xF2,0x29,0x78,0x86,0xCF,0x76,0x0B,0x60,0x82,0x82,0x33,
        0x8F
    }
    local function _nice解密(Data, Size)
        local Data = ffi.cast("char*", Data)
        local Key_Step = 1
        for i = 0, Size - 1, 1 do
                Data[i] = bit.bxor(Data[i], niceKey[Key_Step])
                Key_Step = Key_Step + 1
                if Key_Step == 34 then
                    Key_Step = Key_Step + 1
                end
                if Key_Step == 258 then
                    Key_Step = 1
                end
        end
    end

  local audioKey={0x49,0x6F,0x4C,0x61,0x71,0x44,0x55,0x6B,0x4A,0x67,0xC1,0xBA,0xCC,0xEC,0x40,0x35,0x39,0x39,0x5E,0x21}
  local function _audio解密(Data, Size)
        local Data = ffi.cast("char*", Data)
        local Key_Step = 1
        for i = 0, Size - 1, 1 do
            Data[i] = bit.bxor(Data[i], audioKey[Key_Step])
            Key_Step=Key_Step+1
            if Key_Step == #audioKey +1 then
               Key_Step = 1
            end
        end
    end
    local Key2 = {0xBE,0xB4,0xF9,0x81,0x05,0xFD,0x6F,0x2D,0x64,0x62,0xEB,0x7E,0xCA,0x64,0x96,0xB2,0x19,0x15,0x42,0x9A,0xC8,0xB3,0xD0,0x73,0x25,0x2A,0x83,0x85,0xA2,0xB1,0x07,0xCF,0x98,0xC5,0x15,0xFC,0x10,0xE5,0x19,0xFA,0xEE,0x6E,0x35,0x40,0x71,0xF4,0xA7,0xA7,0xD3,0x13,0x04,0xFE,0x55,0x87,0x30,0x0B,0xE3,0x86,0x5C,0xD9,0x7A,0xE9,0x8A,0xB1,0x5B,0x1C,0xE4,0x05,0x4F,0x98,0xA3,0x32,0xFA,0x47,0xAA,0x5A,0x7F,0x90,0x03,0x30,0x81,0xDB,0xB0,0x8F,0xAD,0x08,0x7B,0x12,0x96,0x0B,0x1A,0x88,0x8A,0x3E,0x80,0x06,0xE3,0x82,0xE3,0x55,0x10,0xA3,0x58,0x3B,0x6F,0xD1,0x04,0x0E,0xDC,0xD4,0x8B,0x53,0x83,0x2D,0x59,0x9E,0x39,0xF9,0x04,0x54,0x9F,0xD3,0x6D,0x45,0x7F,0x1B,0xA6,0xBC,0xC5,0xA4,0x76,0xFB,0xAC,0xAD,0x20,0xDD,0x83,0x76,0x21,0xDB,0x04,0x6D,0x34,0xC1,0x7E,0xC6,0x05,0x5E,0xE4,0xE1,0xCC,0xE8,0x7E,0x8F,0xB4,0x3B,0x36,0x14,0xBB,0x54,0x2B,0x46,0x48,0x38,0x5F,0x8E,0xA6,0xD5,0x0D,0x7B,0x1B,0xC1,0xD9,0x28,0x50,0x33,0x9F,0xAB,0xC5,0xB8,0x17,0x49,0xD7,0xE2,0xD7,0x8C,0x7E,0x1D,0xF7,0xE3,0xA7,0x70,0xB9,0xCB,0xB1,0xBD,0x26,0xFB,0x63,0xEF,0x21,0x2E,0x51,0x69,0xC7,0x0B,0x0F,0x57,0x3F,0x82,0x9B,0x89,0x4D,0x04,0x3E,0xE0,0x6D,0x64,0x60,0xD1,0x11,0x89,0xDD,0x28,0xD2,0xA9,0x09,0x0F,0x76,0x92,0x0D,0xA3,0x49,0xD5,0x97,0xE7,0xF7,0x6E,0x1C,0xCC,0x7D,0x27,0xDC,0x76,0x49,0x1E,0x24,0xB6,0x8D,0xCF,0x50,0xC1,0x9C,0x90,0xDE,0x96,0x50}
 local function _org解密(Data, Size)
    local Data = ffi.cast("char*", Data)
    local Key_Step = 1
    for i = 0, Size - 1, 1 do
        Data[i] = bit.bxor(Data[i], Key2[Key_Step])
        Key_Step = Key_Step + 1
        if Key_Step == 34 then
            Key_Step = Key_Step + 1
        end
        if Key_Step == 258 then
            Key_Step = 1
        end
    end
end

function wdf:初始化(路径,模式)
    self.File  = require("文件类")(路径)
    self.List  = {}
    local head = self.File:读入数据(new("WDF_HEADER"))
    local flag = ffi.string(head.Flag,4)
    self.File:移动读写位置(head.Offset,self.File.SEEK_SET)
    self.Clist = self.File:读入数据(new("FILELIST[?]",head.Number))
    if 模式 == "nice.rpk" then
        _nice解密(self.Clist, ffi.sizeof(self.Clist))
    elseif 模式 == "audio/1115.mp3" or 模式 == "audio/1222.mp3"  then
        _audio解密(self.Clist, ffi.sizeof(self.Clist))
   elseif 模式 == "org3.rpk" or 模式 == "org.rpk"  then
       _org解密(self.Clist, ffi.sizeof(self.Clist))


    end

    local MaxSize = 0
    for i = 0, head.Number - 1, 1 do
        self.List[self.Clist[i].Hash] = self.Clist[i]
        if MaxSize < self.Clist[i].Size then
            MaxSize = self.Clist[i].Size
        end
    end
    if _Max < MaxSize then
        _Max = MaxSize
        _Ptr = ffi.new("char[?]", MaxSize)
    end
end




function wdf:读数据(Hash)
  --_Ptr=nil

    if type(Hash) == "string" then
        Hash = tonumber(Hash)
    end
  -- print(Hash)
    --if 记录[Hash]~=nil then
    -- print(记录[Hash].a,记录[Hash].b,3)
    -- return 记录[Hash].a,记录[Hash].b
      --end
    if self.List[Hash] then
        self.File:移动读写位置(self.List[Hash].Offset,self.File.SEEK_SET)
        self.File:读入数据(_Ptr,self.List[Hash].Size)

        return _Ptr,self.List[Hash].Size
    else
        --print(Hash)
    end
end

function wdf:取文件(Hash)
    return self:读数据(Hash)
end

function wdf:取纹理(Hash)
    return require("gge纹理类")(self:读数据(Hash))
end

function wdf:取精灵(Hash)
    return require("gge精灵类")(self:取纹理(Hash))
end

function wdf:读偏移(Hash)
    if self.List[Hash] then
        return self.List[Hash].Offset, self.List[Hash].Size
    end
end

function wdf:取偏移(Hash)
    if type(Hash) == "string" then
        Hash = tonumber(Hash)
    end
    if self.List[Hash] then
        return self.List[Hash].Offset
    end
end

function wdf:取长度(Hash)
    if type(Hash) == "string" then
        Hash = tonumber(Hash)
    end
    if self.List[Hash] then
        return self.List[Hash].Size
    end
end

function wdf:置注释(path)
    local ini = __gge.readfile(path)
    if ini then
        slot3, slot4, slot5 = ini:gmatch("([^\r\n]+)")
        if ini.gmatch("([^\r\n]+)") then
            local param, value = line:match("^(.-)%s*=%s*(.+)$")
            if param and value then
                if not self.List[value] then
                    self.List[value] = self.List[tonumber(param, 16)]
                    if not self.List[value] then
--                        print("ID不存在", value, param, tonumber(param, 16))
                    end
                else
          --          print("路径重复", self.路径, value)
                end
            end
        end
    else
        error("ini不存在！", level)
    end
    return self
end


return wdf
